---
layout: post
title:  "MySQL 执行计划详解"
date:   2017-07-12 17:21:54
author: umi
categories: MySQL
tags: MySQL
excerpt: MySQL执行计划详细说明！
---


* content
{:toc}






## 执行计划



* id 列
  * id列中的数据为一组数字，表示执行SELECT语句的顺序
  * id值相同时，执行顺序由上至下
  * id值越大优先级越高，越先被执行
* select_type 列
  * SIMPLE： 不包含子查询或是UNION操作的查询
  * PRIMARY： 查询中如果包含任何子查询，那么最外层的查询则被标记为PRIMARY
  * SUBQUERY： select列表中的子查询
  * DEPENDENT SUBQUERY： 依赖外部结果的子查询
  * UNION：union操作的第二个或是之后的查询的值为union
  * DEPENDENT UNION：当union作为子查询时，第二或是第二个后的查询select_type值
  * UNION RESULT：union产生的结果集
  * DERIVED：出现在from子句中的子查询
* table 列
  * 输出数据行所在的表的名称
  * <union M, N>由id为M， N查询union产生的结果集
  * <derivedN>/<subqueryN> 由id为N的查询产生的结果集
* partitions 列
  * 对于分区表，显示查询的分区id
  * 对于非分区表，显示为NULL
* type 列
  * 以下性能从高到低排列
  * system：这是const联接类型的一个特例，当查询的表只有一行时使用
  * const：表中有且只有一个匹配的行时使用，如对主键或是唯一索引的查询，这是效率最高的联接方式
  * eq_ref：唯一索引或主键查找，对于每个索引建，表中只有一条记录与之匹配
  * ref：非唯一索引查找，返回匹配某个单独值的所有行
  * ref_or_null：类似于ref类型的查询，但是附加了对NULL值列的查询
  * index_merge：该联接类型表示使用了索引合并优化方法
  * range：索引返回扫描，常见于between、>、<这样的查询条件
  * index：full index scan 全索引扫描，同ALL的区别是，遍历的是索引树
  * ALL：FULL TABLE scan 全表扫描，这是效率最差的联接方式
* extra 列
  * Distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作
  * Not exists：使用not exists来优化查询
  * Using filesort：使用额外操作进行排序，通常会出现在order by或group by查询中
  * Using index：使用了覆盖索引进行查询