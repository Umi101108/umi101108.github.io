---
layout: post
title:  "数据库设计规范"
date:   2017-07-07 17:21:54
categories: MySQL
tags: MySQL
excerpt: 整理了一份数据库设计规范！
---

* content
{:toc}


* 数据库命名规范
* 数据库基本设计规范
* 数据库索引设计规范
* 数据库字段设计规范
* SQL开发规范
* 数据库操作规范




## 1. 数据库命名规范

* 所有数据库对象名称必须使用小写字母并用下划线分割（**大小写敏感**）
* 所有数据库对象名称禁止使用[MySQL保留关键字](https://dev.mysql.com/doc/refman/5.7/en/keywords.html)
* 数据库对象的命名要能做到见名识义，并且最好不要超过32个字符
* 临时库表必须以tmp为前缀并以日期为后缀
* 备份库，备份表必须以bak为前缀并以日期为后缀
* 所有存储相同数据的列名和列类型必须一致



## 2. 数据库基本设计规范

* MySQL5.5 之前MyISAM（默认存储引擎）情况
* 所有表必须使用Innodb存储引擎
  * 5.6以后的默认引擎
  * 支持事务，行级锁，更好的恢复性，高并发下性能更好
* 数据库和表的字符集统一使用**UTF8**
  * 统一字符集可以避免由于字符集转换产生的乱码
  * MySQL中UTF8字符集汉字占3个字节，ASCII码占用1个字节
* 所有表和字段都需要添加注释
  * 使用comment从句添加表和列的备注
  * 从一开始就进行数据字典的维护
* 尽量控制单表数据量的大小，建议控制在500万以内
  * 500万并不是MySQL数据库的限制
  * MySQL存储限制取决于存储设置和文件系统
  * 可以用历史数据归档，分库分表等手段来控住数据量大小
* 谨慎使用MySQL分区表
  * 分区表在物理上表现为多个文件，在逻辑上表现为一个表
  * 谨慎选择分区键，跨分区查询效率可能更低
  * 建议采用物理分表的方式管理大数据
* 尽量做到冷热数据分离，减小表的宽度
  * 减少磁盘IO，保证热数据的内存缓存命中率
  * 利用更有效的利用缓存，避免读入无用的冷数据
  * 经常一起使用的列放到一个表中
* **禁止**在表中建立预留字段
  * 预留字段的命名很难做到见名识义
  * 预留字段无法确认存储的数据类型，所以无法选择合适的类型
  * 对预留字段类型的修改，会对表进行锁定（修改字段的成本大于增加字段）
* 禁止在数据库中存储图片，文件等二进制数据
  * 数据文件太大，IO操作非常耗时，影响性能
  * 图片文件存在服务器上，数据库中只保存地址
* 禁止在线上做数据库压力测试
* 禁止从开发环境，测试环境直接连接生产环境数据库





## 3. 索引设计规范

* 索引对数据库的查询性能来说是非常重要的

  * 不要滥用索引

* 限制每张表上的索引数量，建议单张表索引不超过5个

  * 索引并不是越多越好！索引可以提高效率同样可以降低效率
  * 索引可以增加查询效率，但同样也会降低插入和更新效率
  * **禁止**给表中的每一列都建立单独的索引

* InnoDB是按照哪个索引的顺序来组织表的呢？

  * 主键！

* 每个InnoDB表必须有一个主键

  * 不使用更新频繁的列作为主键，不使用多列主键

    InnoDb是索引组织表，主键频繁被更新，数据存储的逻辑顺序要频繁变动，带来大量的IO操作，影响性能

  * 不使用UUID，MD5，HASH，字符串列作为主键

    因为无法保证顺序增长

  * 主键**建议**选择使用自增ID值

* 常见索引列建议

  * select、update、delete语句的where从句中的lie
  * 包含在order by、 group by、distinct中的字段
  * 多表join 的关联列

* 如何选择索引列的顺序

  * 区分度最高的列放在联合索引的最左侧
  * 尽量把字段长度小的列放在联合索引的最左侧
  * 使用最频繁的列放到联合索引的左侧

* 避免建立冗余索引和重复索引

  * primary key(id)、index(id) 、unique index(id)
  * index(a, b, c)、index(a, b)、index(a)

* 对应频繁的查询优先考虑使用覆盖索引

  * 覆盖索引：就是包含了所有查询字段的索引
  * 可以避免Innodb表进行索引的二次查找，提升查询效率
  * 可以把随机IO变为顺序IO加快查询效率

* 尽量避免使用外键

  * 不建议使用外键约束，但一定在表与表之间的关联键上建立索引
  * 外键可用于保证数据的参照完整性，但建议在业务端实现
  * 外键会影响父表和子表的写操作从而降低性能



## 4. 数据库字段设计规范

* 字段类型的选择，会直接影响数据库的性能

* 优先选择符合存储需要的最小的数据类型

  * 将字符串转化为数字类型存储

    INET_ATON('255.255.255.255') = 429497295

    INET_NTOA('429497295') = '255.255.255.255'

* 优先选择符合存储需要的最小的数据类型

  * 对于非负型的数据来说，要优先使用无符号整型来存储

    无符号相对于有符号可以多出一倍的存储空间

  * 对于非负数据采用无符号整型进行存储

    SIGNED INT -2147483648~2147483647

    UNSIGNED INT 0~4294967295

* 优先选择符合存储需要的最小的数据类型

  * VARCHAR(n) 中的n代表的是字符数，而不是字节数
  * 使用UTF8存储汉字varchar(255)=765个字节
  * 过大的长度会消耗更多的内存

* 避免使用TEXT、BLOB数据类型

  * 建议把BLOB或是TEXT列分离到单独的扩展表中
  * TEXT或BLOB类型只能使用前缀索引

* 避免使用ENUM数据类型

  * 修改ENUM值需要使用ALTER语句
  * ENUM类型的order by操作效率低，需要额外操作
  * 禁止使用数值作为ENUM的枚举值

* 尽可能把所有列定义为NOT NULL

  * 索引NULL列需要额外的空间来保存（空还是非空），所以需要占用更多的空间
  * 进行比较和计算时需要对NULL值做特别的处理

* 字符串存储日期型的数据（不正确的做法）

  * 无法用日期函数进行计算和比较
  * 用字符串存储日期要占用更多的空间

* 使用TIMESTAMP或DATETIME类型存储时间

  * TIMESTAMP 1970-01-01 00:00:01~2018-01-19 03:14:07
  * TIMESTAMP 占用4字节和INT相同，但比INT可读性高

* 同财务相关的金额类数据，必须使用decimal类型

  * DECIMAL类型为精准浮点数，在计算时不会丢失精度
  * 占用空间由定义的宽度决定
  * 可用于存储比bigint更大的整数数据