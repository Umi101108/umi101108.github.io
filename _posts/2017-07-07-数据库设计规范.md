---
layout: post
title:  "数据库设计规范"
date:   2017-07-07 17:21:54
categories: MySQL
tags: MySQL
excerpt: 整理了一份数据库设计规范！
---

* content
{:toc}


* 数据库命名规范
* 数据库基本设计规范
* 数据库索引设计规范
* 数据库字段设计规范
* SQL开发规范
* 数据库操作规范




## 1. 数据库命名规范

* 所有数据库对象名称必须使用小写字母并用下划线分割（**大小写敏感**）
* 所有数据库对象名称禁止使用[MySQL保留关键字](https://dev.mysql.com/doc/refman/5.7/en/keywords.html)
* 数据库对象的命名要能做到见名识义，并且最好不要超过32个字符
* 临时库表必须以tmp为前缀并以日期为后缀
* 备份库，备份表必须以bak为前缀并以日期为后缀
* 所有存储相同数据的列名和列类型必须一致



## 2. 数据库基本设计规范

* MySQL5.5 之前MyISAM（默认存储引擎）情况
* 所有表必须使用Innodb存储引擎
  * 5.6以后的默认引擎
  * 支持事务，行级锁，更好的恢复性，高并发下性能更好
* 数据库和表的字符集统一使用**UTF8**
  * 统一字符集可以避免由于字符集转换产生的乱码
  * MySQL中UTF8字符集汉字占3个字节，ASCII码占用1个字节
* 所有表和字段都需要添加注释
  * 使用comment从句添加表和列的备注
  * 从一开始就进行数据字典的维护
* 尽量控制单表数据量的大小，建议控制在500万以内
  * 500万并不是MySQL数据库的限制
  * MySQL存储限制取决于存储设置和文件系统
  * 可以用历史数据归档，分库分表等手段来控住数据量大小
* 谨慎使用MySQL分区表
  * 分区表在物理上表现为多个文件，在逻辑上表现为一个表
  * 谨慎选择分区键，跨分区查询效率可能更低
  * 建议采用物理分表的方式管理大数据
* 尽量做到冷热数据分离，减小表的宽度
  * 减少磁盘IO，保证热数据的内存缓存命中率
  * 利用更有效的利用缓存，避免读入无用的冷数据
  * 经常一起使用的列放到一个表中
* **禁止**在表中建立预留字段
  * 预留字段的命名很难做到见名识义
  * 预留字段无法确认存储的数据类型，所以无法选择合适的类型
  * 对预留字段类型的修改，会对表进行锁定（修改字段的成本大于增加字段）
* 禁止在数据库中存储图片，文件等二进制数据
  * 数据文件太大，IO操作非常耗时，影响性能
  * 图片文件存在服务器上，数据库中只保存地址
* 禁止在线上做数据库压力测试
* 禁止从开发环境，测试环境直接连接生产环境数据库





## 3. 索引设计规范

* 索引对数据库的查询性能来说是非常重要的

  * 不要滥用索引

* 限制每张表上的索引数量，建议单张表索引不超过5个

  * 索引并不是越多越好！索引可以提高效率同样可以降低效率
  * 索引可以增加查询效率，但同样也会降低插入和更新效率
  * **禁止**给表中的每一列都建立单独的索引

* InnoDB是按照哪个索引的顺序来组织表的呢？

  * 主键！

* 每个InnoDB表必须有一个主键

  * 不使用更新频繁的列作为主键，不使用多列主键

    InnoDb是索引组织表，主键频繁被更新，数据存储的逻辑顺序要频繁变动，带来大量的IO操作，影响性能

  * 不使用UUID，MD5，HASH，字符串列作为主键

    因为无法保证顺序增长

  * 主键**建议**选择使用自增ID值

* 常见索引列建议

  * select、update、delete语句的where从句中的lie
  * 包含在order by、 group by、distinct中的字段
  * 多表join 的关联列

* 如何选择索引列的顺序

  * 区分度最高的列放在联合索引的最左侧
  * 尽量把字段长度小的列放在联合索引的最左侧
  * 使用最频繁的列放到联合索引的左侧

* 避免建立冗余索引和重复索引

  * primary key(id)、index(id) 、unique index(id)
  * index(a, b, c)、index(a, b)、index(a)

* 对应频繁的查询优先考虑使用覆盖索引

  * 覆盖索引：就是包含了所有查询字段的索引
  * 可以避免Innodb表进行索引的二次查找，提升查询效率
  * 可以把随机IO变为顺序IO加快查询效率

* 尽量避免使用外键

  * 不建议使用外键约束，但一定在表与表之间的关联键上建立索引
  * 外键可用于保证数据的参照完整性，但建议在业务端实现
  * 外键会影响父表和子表的写操作从而降低性能



## 4. 数据库字段设计规范

* 字段类型的选择，会直接影响数据库的性能

* 优先选择符合存储需要的最小的数据类型

  * 将字符串转化为数字类型存储

    INET_ATON('255.255.255.255') = 429497295

    INET_NTOA('429497295') = '255.255.255.255'

* 优先选择符合存储需要的最小的数据类型

  * 对于非负型的数据来说，要优先使用无符号整型来存储

    无符号相对于有符号可以多出一倍的存储空间

  * 对于非负数据采用无符号整型进行存储

    SIGNED INT -2147483648~2147483647

    UNSIGNED INT 0~4294967295

* 优先选择符合存储需要的最小的数据类型

  * VARCHAR(n) 中的n代表的是字符数，而不是字节数
  * 使用UTF8存储汉字varchar(255)=765个字节
  * 过大的长度会消耗更多的内存

* 避免使用TEXT、BLOB数据类型

  * 建议把BLOB或是TEXT列分离到单独的扩展表中
  * TEXT或BLOB类型只能使用前缀索引

* 避免使用ENUM数据类型

  * 修改ENUM值需要使用ALTER语句
  * ENUM类型的order by操作效率低，需要额外操作
  * 禁止使用数值作为ENUM的枚举值

* 尽可能把所有列定义为NOT NULL

  * 索引NULL列需要额外的空间来保存（空还是非空），所以需要占用更多的空间
  * 进行比较和计算时需要对NULL值做特别的处理

* 字符串存储日期型的数据（不正确的做法）

  * 无法用日期函数进行计算和比较
  * 用字符串存储日期要占用更多的空间

* 使用TIMESTAMP或DATETIME类型存储时间

  * TIMESTAMP 1970-01-01 00:00:01~2018-01-19 03:14:07
  * TIMESTAMP 占用4字节和INT相同，但比INT可读性高

* 同财务相关的金额类数据，必须使用decimal类型

  * DECIMAL类型为精准浮点数，在计算时不会丢失精度
  * 占用空间由定义的宽度决定
  * 可用于存储比bigint更大的整数数据



## 5. 数据库SQL开发规范

* 建议使用预编译语句进行数据库操作
  * 只传参数，比传递SQL语句更高效
  * 相同语句可以一次解析，多次使用，提高处理效率
* 避免数据类型的隐式转换
  * 隐式转换会导致索引失效
* 合理利用存在索引，而不是盲目增加索引
* 充分利用表上已经存在的索引
  * 避免使用双%号的查询条件，或前置%
  * 一个SQL只能利用到复合索引中的一列进行范围查询
  * 使用left join 或 not exists 来优化not in 操作
* 数据库设计时，应该要对以后扩展进行考虑
* 程序连接不同的数据库使用不同的账号，禁止跨库查询
  * 为数据库迁移和分库分表留出余地
  * 降低业务耦合度
  * 避免权限过大而产生的安全风险
* 禁止使用SELECT *， 必须使用 SELECT <字段列表>查询
  * 消耗更多的CPU和IO以及网络带宽资源
  * 无法使用覆盖索引
  * 可减少表结构变更带来的影响
* 禁止使用不含字段列表的INSERT 语句
  * 可减少表结构变更带来的影响
* 避免使用子查询，可以把子查询优化为join操作
  * 子查询的结果集无法使用索引
  * 子查询会产生临时表操作，如果子查询数据量大则严重影响效率
  * 生成的临时表会消耗过多的CPU及IO资源
* 避免使用JOIN 关联太多的表
  * 每 join 一个表会多占用一部分内存（join_buffer_size）
  * 会产生临时表操作，影响查询效率
  * MySQL最多允许关联61个表，建议不超过5个
* 减少同数据库的交互次数
  * 数据库更适合处理批量操作
  * 合并多个相同的操作到一起，可以提高处理效率
* 使用 in 代替 or
  * in 的值不要超过500个
  * in 操作可以有效的利用索引，or很少能用到索引
* 禁止使用 order by rand() 进行随机排序
  * 会把表中所有符合条件的数据装载到内存中进行排序
  * 会消耗大量的CPU和IO及内存资源
  * 推荐在程序中获取一个随机值，然后在数据库中获取数据的方式
* 禁止在WHERE从句中对列进行函数转换和计算
  * 对列进行函数转换或计算会导致无法使用索引
  * where date(createtime)='20170711' 无法使用索引，使用下面的等效语句
  * where createtime >= '20170711' and createtime < '20170712'
* 在明显不会有重复值时使用UNION ALL  而不是 UNION
  * UNION 会把所有数据放到临时表中后再进行去重操作
  * UNION ALL 不会再对结果集进行去重操作
* 拆分复杂的大SQL为多个小SQL
  * MySQL一个SQL只能使用一个CPU进行计算
  * SQL拆分后可以通过并行执行来提高处理效率



## 6. 数据库操作行为规范

* 超100万行的批量写操作，要分批多次进行操作
  * 大批量操作可能会造成严重的主从延迟
  * binlog日志为row格式时会产生大量的日志
  * 避免产生大事务操作
* 对大表数据结构的修改一定要谨慎，会造成严重的锁表操作。尤其是生产环境，是不能忍受的
* 对于大表使用**pt-online-schema-change**修改表结构
  * 避免大表修改产生的主从延迟
  * 避免在对表字段进行修改时进行锁表
* 禁止为程序使用的账号赋予super权限
  * 当达到最大连接数限制时，还允许1个有super权限的用户连接
  * super权限只能留给DBA处理问题的账号使用
* 对于程序连接数据库账号，遵循权限最小原则
  * 程序使用数据库账号只能在一个DB下使用，不准跨库
  * 程序使用的账号原则上不准有drop权限